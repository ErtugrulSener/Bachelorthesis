% !TeX root = ../Bachelorarbeit.tex
\chapter{Auswertung}
Das Passwort war jahrzehntelanger Vorherrscher in der Authentifikation im Web und schien eine kurze Weile auch sicher. Nach dem die ersten Bruteforce-Angriffe auf Formulare angeggangen wurden, mussten neue Regeln für Passwörter her. Der Nutzer durfte sie nicht mehr nach eigenem Ermessen wählen, da der Imageschaden durch z.B: die Infiltrierung einer wichtigen hochrangigen Person eines Unternehmens zu groß wurde. Die Fälle der Data-Breaches und Leaks wurden trotz Passwort-Policy Ansätzen und der Einführung des zweiten Faktors nicht weniger sondern im Gegenteil: Sie häuften sich mehr und mehr. Passwörter wurden theoretisch durch erzwungene Sonderzeichen und einer Mindestlänge komplexer, allerdings wurde genau hier nicht mit der Natur des Menschen gerechnet. Da Formulare nun mehr und mehr Passwörter abzulehnen schienen, beggangen Menschen die Sicherheitsfeatures instinktiv zu umgehen. Darauf folgten die 'zeitlich begrenzten Passwörter', welche aus dem selben Grund, dem Bequemlichkeitsproblem, scheiterten. Neuere Verfahren sollten die alteingesessenen ersetzen oder zunächst ein Mal unterstützen. Die neue Zeit des Smartphones ermöglichte den Nutzern ihre Geräte zur Authentifikation zu nutzen, wofür sie davor kostspielige Geräte kaufen hätten müssen. Die Zeit der Einmalkennwörter brach an und Apps wie der Google Authenticator oder der Microsoft Authenticator gewannen mehr und mehr an Popularität. Mit der Zeit wurden allerdings auch diese 'weiteren Schritte' zur Authentifikation dem Nutzer zu lästig. Vor allem wichtige Dienste wie Banken führen kein Sessionmanagement und nötigen den User häufig zur mehrmaligen Authentifikation während einer Sitzung. Und genau an diesem Standpunkt setzen die neuesten Verfahren an. Die Webauthentikation ist dem Passwort in vielen Dingen überlegen. Zunächst ein Mal werden nur noch zufällig generierte Schlüssel ausgetauscht. Außerdem geschieht das über Challenge-Response-Verfahren wodurch Wiederholungsangriffe vermieden werden. Der Nutzer ist nicht mehr der Kern der Authentifikation sondern der Authentifikator (das Gerät) selbst. Bei neueren public-private-key Verfahren gibt es keine Geheimnisse, die auf einfachste Art und Weise (z.B: über Keylogger, Trojaner oder Shoulder Surfing) entwendet werden könnten. Die Verantworung zur sicheren Aufbewahrung von Passwörtern hat sich vom Nutzer auf die Betriebssysteme verschoben, die die privaten Schlüssel sichern müssen. Die \ac{mitm} - Problematik schien immernoch nicht gelöst. So ist die Kommunikation dann durch den \ac{mitm} angreifbar, wenn der Aussteller des Zertifikats nicht bekannt ist. Die Webauthentikation bietet einem Mann in der Mitte allerdings keine einfache Möglichkeit, die Identität des Nutzers anzunehmen.
\newpage

Abseits der Problematik bietet der FIDO2 - Standard mit Webauthn und CTAP2 die Kommunikation über verschiedenste Authentifikatoren und bietet damit potenziell sehr vielfältige Lösungsansätze für Authentifikationen im Webbereich.
Dennoch ist die Umsetzung des Hauptbetriebssystems Windows aus UX-Sicht nur suboptimal. Gleichzeitig ist die Implementation von Webauthn auf Clientseite zwar größtenteils schon möglich, auf Serverseite fehlt es bei Javascript basierenden Webseiten aber an ausgereiften Web-API's. Die Abstraktion der Vorgänge im Webauthn - Protokoll durch vorhandene API's (wie die genutze im Prototyp) hat den Vorteil, dass der Implementationsaufwand durch eine Senkung der Komplexität sinkt. Gleichzeitig muss bei Fehlern in der abstrahierten Bibliothek ein Mehraufwand an Verständnis dessen, was die Bibliothek macht, aufgetrieben werden. Gemessen daran, dass man das Protokoll allerdings nur einmalig implementieren muss und die FIDO-Alliance große Unterstützung für Webseiten für alle möglichen Programmiersprachen bietet, scheint dieses Argument entkräftigt.

Der Prototyp beweist zweierlei Dinge. Zunächst ein Mal ist es möglich, einen Nutzer bereits mit einem einzigen sicheren Faktor und dessen Nutzernamen zu authentifizieren. Das Passwort sollte im Jahre 2020 eher zur Ausnahme in der Sicherung und wenn überhaupt nur mit einem zweiten Faktor verwendet werden dürfen, sofern es dem User nicht möglich ist die sichereren Verfahren zur Authentifikation zu nutzen. Dies könnte zum Beispiel dann der Fall sein, wenn es dem Nutzer an den benötigten Geräten (der Hardware) fehlt oder die Hardware nicht mit dem Betriebssystem kompatibel ist. Außerdem beweist die Webseite, dass die Implementation der neueren Verfahren keine große Hürde darstellt und einem potenziellen Unternehmen auf lange Sicht viele Supportanfragen zwecks vergessenen Passwörtern oder gekaperten Accounts ersparen kann.

Es gillt noch zu schauen, inwiefern die Anforderungen aus dem Kapitel für sichere Webseiten vom Prototypen erfüllt werden konnten:

\begin{itemize}
\item \textbf{Immer mehr Nutzer sorgen für mehr Authentifikationen pro Sekunde und damit für eine höhere Auslastung}

Bei der Wahl der Umgebung des Backends wurde bewusst NodeJS gewählt, das im Kern bereits eine asynchrone Verarbeitung hat. Das heißt das diese Programmiersprache und die genutzte Library 'ExpressJS' in der Lage sind, viele Anfragen verschiedenster Nutzer parallel zu bearbeiten. Die Anfragen blockieren sich nicht untereinander. Dazu besitzt der Prototyp bewusst keine statische Verbindung zur Datenbank sondern ein Pooling. Es baut also bei Serverstart einige (nicht spezifiziert) Verbindungen zur Datenbank auf. Sollte es mal sein, dass eine dieser Verbindungen abbricht, dann stürzt der NodeJS Server nicht ab sondern kann bei der nächsten Anfrage einfach eine neue Verbindung aus dem Pool für die Anfrage verwenden. Die Authentifikation von vielen verschiedenen Nutzern ist dem Prototypen dadurch problemlos möglich.

\item \textbf{Webseiten sind über das offene Netz zugänglich und bieten damit eine große Angriifsfläche für Brute-Force Angriffe}

Der Prototyp besitzt keine konkreten Vorsichtsmaßnahmen gegen Bruteforce - Angriffe. Dies müsste in Folgeversionen implementiert werden, da sonst eben genau die geschilderte Gefahr der Erratung von User Credentials über das Durchprobieren von Passwörtern groß ist. Bei dem Verfahren der Webauthn ist kein Schutz gegen Bruteforce - Angriffe nötig, da diese keine 'offenen Credentials' wie dem Passwort besitzen das erraten werden könnte. Anders sieht es bei der TOTP-Authentifikation aus, hier ist eine Brute-Force Gefahr sehr hoch, da der TOTP Code nur aus einer sechsstelligen Zahl besteht. Das sind genau 1.000.000 Möglichkeiten, die der Angreifer innerhalb von 30 Sekunden (alle 30 Sekunden zyklisch) ausprobieren muss. So würde er die Authentifikation durch ein Gerät umgehen können, dies muss in Folgeversionen verhindert werden und wurde zeitbedingt nicht implementiert. Auch war es geplant diesen Schutz anhand einer Firewall vor der Webseite zu stützen, wodurch dies programmatisch vernachlässigt werden könnte.

\item \textbf{Webseiten besitzen mehr Möglichkeiten als je zuvor um Nutzer zu authentifizieren, von dem muss sie aber erst Gebrauch machen}

Die Verfahren des 21. Jahrhunderts werden dem Nutzer wunderbar präsentiert und können von ihm für die Authentifikation genutzt werden. Bei der Username \& Passwortauthentifikation fehlt es an einer Registrierung. Abseits dessen, sind die TOTP und Webauthn Registration bereits sicher und bequem implementiert. Auch werden alle drei Kateogorien durch ihre entsprechenden Verfahren bedient.

\item \textbf{Webanwendungen speichern üblicherweise Nutzerkonten bzw. personenbezogene Daten}

Personenbezogene Daten werden vom Prototypen nicht gespeichert, da es sich hierbei nur um ein Modul einer Webanwendung handelt, ist dies allerdings auch nicht nötig. Andere Daten wie Passwörter werden mit einem sicheren Hashingverfahren (Salted and Peppered SHA256) in der Datenbank persistiert und sogar auf Clientseite wie empfohlen zusätzlich verschlüsselt und dann übertragen. Wie bereits erwähnt ist die Speicherung von Biometriedaten nicht nötig, da Webauthn nur einen zufällig generierten Hash als 'credentialID' persistieren muss um die Folgeauthentifikation des Nutzers zu erkennen.

\item \textbf{Webnutzer sind oft unvorsichtig mit Passwörtern und wählen zu leichte}

Dieser Punkt war recht schwierig zu verhindern, obwohl die Verfahren wie man ihn umsetzen kann bereits gut erforscht sind. Die Hauptproblematik von Passwörtern und Passwort Policies wird an diesem Punkt sehr klar. Egal welche Policy für Passwörter gewählt wird, dem Nutzer ist es möglich dennoch unsichere Passwörter zu wählen. Wählt man zu viele Richtlinien wird der Nutzer sich aufgrund seiner Beqeuemlichkeit auf kurz oder lang bewusst für diese Unsicherheit entscheiden. Nutzt man gar keine Policy dann ist dem Nutzer gar keine Grenzen an einfachen Passwören wie ``1234'' gesetzt. Der Prototyp hat nur eine simple Policy: Passwörter und Nutzernamen müssen eine Mindeslänge von 8 Zeichen besitzen. Dieses Problem kann nicht so richtig bearbeitet werden, da ein Nutzer im Zweifelsfalle immer seine Bequemlichkeit vor seine Sicherheit stellt was dann zu Identitätsdiebstahl usw. führt.
\end{itemize}

Zum Abschluss der Bachelorarbeit muss noch geklärt werden, welches Verfahren für welchen Nutzertypus geeignet ist. Auch wenn man dies nicht pauschalisieren kann, sollte man zunächst ein Mal klären welcher Nutzer welche Anforderungen stellt. Alle Internetnutzer, ob es nun ein erfahrener Entwickler, ein Casual Erwachsener oder Jugendlicher ist, haben Interesse an dem Schutz ihrer Daten. Auch wenn ihnen die Wichtigkeit ihrer Daten und die Gefährdung größenteils nicht bewusst sind. Jugendliche haben heutzutage nur in seltenen Fällen kein Smartphone und können somit das TOTP-Verfahren oder die Webauthn (falls von der Internetseite umgesetzt und untersützt) verwenden. Älteren Personen fehlt es womöglich an technischer Hardware, doch hier kommt die Authentifikation über PIN (sogenanntes self-signed-device) oder die Stimme am Rechner ins Spiel. Auch wenn kein externes Gerät wie ein Smartphone vorhanden ist, kann häufig bereits der eigene Rechner einige Authentifikationsmethoden unterstützen. Sollte man, aus gegebenen und teilweise genannten Gründen, keine Möglichkeit auf Alternativen zum Passwort besitzen, sollte das Passwort nicht als alleiniger Authentifikator verwendet werden dürfen. Ein zweiter Faktor ist aber nur strikt für das Passwort erforderlich, denn die anderen Verfahren sind nicht so großen Gefahren ausgesetzt wie es das Passwort ist. Die Öffentlichkeit muss sich der Wichtigkeit ihrer Identität bewusst werden, um die Entscheidung über Passwörter und dem erzwungenen zweiten Faktor nachzuvollziehen. Zuletzt bleibt noch zu erwähnen: Der Codename des Prototypen 'clsec' ist ein Kürzel der Wortschöpfung 'Clientless Login' und bedeutet so viel wie ``Die Authentifikation ohne Passwort'' und mach den Prototypen damit zum Beweis dafür, dass diese auch Zukunft hat.
